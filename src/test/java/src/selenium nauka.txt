w elements dajemy ctrl f i wpisujemy 

//input[@id='name']           lub odpowiednik input[class='inputs']

ale w consoli wpisujemy 

$x("//input[@id='name']")

-----------------------------------

- i frame - 
dajê na jakimœ elemencie inspect - a póŸniej naciskam console - na samej górze widzê podœwietlenie na czerwono iframe - wtedy wiem, ¿e parent jest iframe



$x("//div[@class='collapse navbar-collapse']")
------------------------------------------------------

Komendy Java 
System.setProperty("webdriver.chrome.driver", "C://Users//Bartek//eclipse-workspace/chromedriver.exe");
		WebDriver driver = new ChromeDriver();
		driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
String adres = "https://demostore.x-cart.com/";
driver.get(adres)
//driver.findElement(By.id("lst-ib")).sendKeys("sklep narciarski rzeszów");
		
		//driver.findElement(By.linkText("Login")).click();
		Thread.sleep(3000);
		//driver.findElement(By.partialLinkText("Practi")).click();
		//driver.findElement(By.className("")).click();
		driver.findElement(By.xpath("//div[@class='collapse navbar-collapse']")).click();
                driver.findElement(By.id("user_email")).clear(); // szukanie po id oraz czyszczenie pola 
		driver.findElement(By.id("user_email")).sendKeys("adres@test.com"); - przesy³anie danych do formularza

-----------------------
znajdowanie po CSS
klasyczna komenda to:
//input[@id='displayed-text']

ale jak wpiszê 
#displayed-text  to te¿ znajdzie to samo, co u góry 

x pathem tzn ranorex znajdujê coœ takiego:
#displayed-text (to jest z tego co wiem css)
ale naciskam dalej ctrl f i wpisujê coœ takiego:
input[id='displayed-text'] -zalecane 

ale mo¿na te¿ wpisaæ tak:
input#id='displayed-text' i to jest to samo co "input[id='displayed-text']"

W CSS s¹ dwa znaki kluczowe:
1. "#" -> id
2. "." -> Class
---------------
znajdowanie dla klasy - jest coœ takiego:
klasyczny przyk³ad jest taki:
//input[@class='inputs displayed-class']

ale dzia³a te¿ 

input[class='inputs displayed-class']

.displayed-class
input,displayed-class
------------------------

Teamt Wildcars CSS selectors 
^pocz¹tek 
$koniec
*

przyk³ad 
input[class='inputs']
ale jak wpisze coœ takiego input[class^='inputs'] - to znajduje wszystkie stringi zaczynaj¹ce siê od class, tak wiêc u nas s¹ to 2 przypadki

albo koniec stringa 
input[class*='displayed-class'] - to znajdzie klasê inputs displayed-class

Gwiazdka oznacza szukanie gdziekolwiek 
np
input[placeholder*='Enter'] znajdzie placeholder ="enter your name"
----------
lekcja child nodes
fieldset>table to znajduje parenta fieldset oraz szuka w nim dziecka table
----------------------------

Lekcja - junit
--------------
lekcja how to navigate between web pages 
String tytul = driver.getTitle(); - pobranie title strony 

Jak nie chcemy szukaæ po xpath to mo¿na zrobiæ coœ takiegom, szukanie po linku 
String urlToNavigate = "https://sso.teachable.com/secure/42299/users/sign_in?clean_login=true&reset_purchase_session=1";
		driver.navigate().to(urlToNavigate);
--------
driver.navigate().refresh(); - odœwie¿a stronê 
System.out.println(bmw_radio.isSelected()); - sprawdzenie, czy radio button jest zaznaczony 
--------------------

ctrl F - wa¿ne !!
//input[contains(@type, 'radio') and contains (@name, 'cars')]  coœ takiego znajduje w naszym przypoadku 3 elementy i póŸniej mo¿emy je dodaæ do listy w javie 
----------------------
sprawdzenie, czy element jest aktywny, czy nie 
WebElement e1 = driver.findElement(By.id("gs_htif0"));
		System.out.println("E1 is Enabled? " + e1.isEnabled());
-----------------------

Lekacja 101 - dropdown menu 
- jak lista dropdown ma wiele elementów, to ja nie chcê pisaæ wielu xpath - to jest pytanie 
WebElement ele1 = driver.findElement(By.id("carselect")); //to wybiera tylko g³ównego selecta
		Select select_lista = new Select(ele1); //obiekt klasy Select - tu s¹ wszystkie wartoœci zapisane
		select_lista.selectByValue("bmw");
		Thread.sleep(2000);
		
		select_lista.selectByIndex(2);
		Thread.sleep(2000);
		
		select_lista.selectByVisibleText("Honda");
		Thread.sleep(2000);

Natomiast tu tworzymy listê selectów (to siê robi inaczej ni¿ lista readio)
	List<WebElement> moja_lista = select_lista.getOptions();
		int rozmiar = moja_lista.size();
		
		for (int i=0; i<rozmiar; i++) {
			String jednostka = moja_lista.get(i).getText();
			System.out.println(jednostka);
		} 
oraz tu doda³em drukowanie tej listy za pomoc¹ metody get text 

a to jest druga pêtla ze wczeœniejszego przyk³adu, która dzia³a identycznie jak powy¿sza: 

List<WebElement> moja_lista = select_lista.getAllSelectedOptions();
		for (WebElement element : moja_lista) {
			System.out.println(element.getText());
		}
------------------------------------
------------------------------------
	String zwroc = element.getAttribute("class"); - zwraca wartoœæ danego elelementu w htmlu 
---------------------

explicit wait 

WebDriverWait czekaj = new WebDriverWait(driver, 3);
		WebElement pole_email = czekaj.until(
				ExpectedConditions.visibilityOfElementLocated(By.id("user_email")));
		pole_email.sendKeys("ala");
------------------------------------------------------

znajdowanie elementu poprzez java script i klikanie w niego 

WebElement ele = (WebElement) js.executeScript("return document.getElementById('name');");
ele.click();

--------------------------------------------------

java script - znajdowanie elementu, ale nie klikanie go 

WebElement ele = driver.findElement(By.id("mousehover"));
		js.executeScript("arguments[0].scrollIntoView(true);", ele);
		Thread.sleep(2000);
		js.executeScript("window.scrollBy(0, -190);");
	}
----------------------------------------

klikniêcie w element za pomoc¹ java script - to jest to samo co ele.click()

jak checkbox jest ju¿ np zaznaczony to wtedy zwyk³a metoda click nie zadzia³a, bo bêdzie komunikat, ¿e to ju¿ jest zrobione, dlatego wtedy trzeba to zrobiæ za pomoc¹ java script

WebElement ele = driver.findElement(By.id("bmwcheck"));
		js.executeScript("arguments[0].click();", ele);
-----------------------------------------------------

otwieranie nowego okna
String parentHandle = driver.getWindowHandle();
WebElement ele1 = driver.findElement(By.id("openwindow"));
		ele1.click();
Set<String> wszystkie = driver.getWindowHandles();
		for (String handler : wszystkie) {
			System.out.println(handler);
			if (!handler.equals(parentHandle)) {
				driver.switchTo().window(handler);
				Thread.sleep(2000);
				WebElement ele2 = driver.findElement(By.id("search-courses"));
				ele2.sendKeys("ala");
				Thread.sleep(2000);
				driver.close(); // zamyka aktualne okno
				break;
			}
		}

i na koncu znowu prze³¹czamy na okno g³ówne 
driver.switchTo().window(parentHandle);
--------------------------------------------------------------

przyk³ad na znalezienie xpath za pomoc¹ wielu znaków // slash 
/html//table[@id='product']//th[.='Price']

------------------
iframe (jeœli iframe nie ma id albo nazwy, to u¿ywamy numeru, czyli np 0 )
driver.switchTo().frame("courses-iframe");
		WebElement ele1 = driver.findElement(By.id("search-courses"));
driver.switchTo().defaultContent(); // trzeba siê prze³¹czyc ponownie na okno podstawowe i szukamy klasycznie dalej 

WebElement ele2 = driver.findElement(By.id("name"));
--------------------------

wyskakuj¹ce okienka java script 
driver.get(baseUrl);
		WebElement ele1 = driver.findElement(By.id("name"));
		ele1.sendKeys("ala");
		WebElement ele2 = driver.findElement(By.id("alertbtn"));
		ele2.click();
		Thread.sleep(3000);
		Alert alert_okno = driver.switchTo().alert(); //obiekt klasy Alert
		alert_okno.accept();
		//alert_okno.dismiss();
--------------------------------------------------
- hover over oraz scroll za pomoc¹ java script 

private JavascriptExecutor js; //to w klasie g³ównej 
js = (JavascriptExecutor) driver; // to w before 
js.executeScript("window.scrollBy(0, 900);"); //to w teœcie i nic wiêcej 
		Thread.sleep(2000);

a póŸniej hover 

Actions najedz = new Actions(driver);
ajedz.moveToElement(element1).perform(); // i tyle, zero filozofii 
----------------------------------------------
drag and drop przeci¹gnie 
driver.switchTo().frame(0);
Actions akcje = new Actions(driver);
		akcje.dragAndDrop(ele1, ele2).build().perform();

albo coœ takiego, to samo 
action.clickAndHold(fromElement).moveToElement(toElement).release().build().perform();
----------------
--------------------------------------------------------------

znajodwanie xpath ze s³owem contains
//a[contains(@href, 'sign_in')]
w cudzys³owiu jest szukanie stringa czyli czêœci linku

------------------------------------------------------------------
naciskanie przycisku enter na klawiaturze np przy logowaniu 
//trzeba zrobiæ import biblioteki keys 
WebElement ele4 = driver.findElement(By.xpath("//*[@id=\"new_user\"]/div[3]/input"));
		ele4.sendKeys(Keys.ENTER);

ewentulanie za pomoc¹ aciton class
Actions action = new Actions(driver);
		action.keyDown(Keys.COMMAND).sendKeys("a").keyUp(Keys.COMMAND).perform();
-------------------------------
ctrl + a komenda - zaznaczenie wszystkie na stronie
ele1.sendKeys(Keys.CONTROL + "a");
-------------------------------
------------------------------------------------

Znajodwanie elementu po FindBy
@FindBy(id="tab-flight-tab-hp")
WebElement flights_przycisk; 

Ale do tego trzeba te¿ napisaæ konstruktor i wywo³aæ go w innej klasie. 

public framework_factory (WebDriver driver) {
	this.driver = driver;
	PageFactory.initElements(driver, this); // to musi byæ zawsze,kiedy stosujemy FindBy
}

Wywo³anie: 
(pod nazw¹ klasy na samej górze)
framework_factory obiekt_konstruktora;

a w Before ci¹g dalszy czyli 
obiekt_konstruktora = new framework_factory (driver);

Natomiast klasycznie robi siê coœ takiego:
//framework_factory obiekt_konstruktora = new framework_factory (driver); ---- to jest klasycznie 
-----------------------------------------------------------------------------------------------------------
-------------------------

Wa¿ne !!
jeœli chcemy znaleŸæ np. wszystkie elementy na stronie, które s¹ a href, to robimy coœ takiego:

List<WebElement> wszystkie_linki = driver.findElements(By.tagName("a"));

czyli jest to znajdowanie po nazwie tagu
------------------------------------------------------

Log4j
Aby korzystaæ z log4j nale¿y zaimportowaæ dwie biblioteki:
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

a póŸniej w g³ówenej klasie 
public class ala {
	private static final Logger moj_log = LogManager.getLogger(ala.class.getName());

a póŸniej w main 

public static void main(String[] args) {
		moj_log.debug("moj debug log");
		moj_log.error("moj error log");
		
	}
----------------------------------------------------------------------------------------
kiedy chcê skorzystaæ z metody, która jest w innej klasie, ale ta klasa jest w tym samym package, to wtedy tworzê tylko zwyk³y obiekt tej klasy itd.
Ale jeœli ta klasa jest w innym package, to wtedy muszê daæ na samej górze import i nazwa tej klasy, a dopiero póŸniej stworzyæ obiekt
-------------------------------------------
ctrl sfift + f - to komenda formatuj¹ca kod 
-----------------------------------------------

TestNg - 
@AfterMethod  //to jest uruchamiane po ka¿dej metodzie, podobnie jak Before 
------------------

@BeforeClass // a to sie uruchamia na samym pocz¹tku, a dopiero póŸniej jest before method
	public void beforeklasa() {
		System.out.println("przed klasa");
	}

@AfterClass // a to siê wykonuje na samym koñcu, po after method
	public void afterklasa() {
		System.out.println("po klasa");
	}

--------------------------
Mamy  na przyk³ad stronê internetow¹, która ma 10 podstron, tak wiêc stworzyliœmy po jednej klasie dla ka¿dej podstrony, czyli mamy 10 klas. Ale pytanie jak uruchomiæ 10 klas za jednym razem ? Tutaj przychodzi z pomoc¹ test suite.
Trzeba w takim przypadku utworzyæ plik XML, ktory test NG przeczyta. 
Klikamy na projekt i tworzymy zwyk³y nowy plik i tytu³ujemy go tak: plik.xml

Mo¿e on wygl¹daæ tak:

	<suite name="regression test suite">
	<test name="app test">
		<classes>
		<class name="lekcja_jeden.method_class_ann_158"> </class>
		<class name="lekcja_jeden.klasa2_test_suite_159"> </class>
		</classes>
	
	</test>
	
	</suite>

lekcja_jeden to nazwa package
---------------------------------------
s³owo kluczowe extends
- jak chcê zaimportowaæ klasê, która jest w innym package, to muszê daæ w importach nazwê klasy oraz tê konkretn¹ funkcjê, czyli:

import before_suite.Lekcja160_common_things; (nazwa package i po kropce nazwa klasy g³ównej, czyli nazwa pliku)

oraz pod importem coœ takiego:

public class method_class_ann_158 extends Lekcja160_common_things
---------------------------------------------------------------------

Test NG
tak siê testuje w test ng 

int result = obj.sumNumbers(1, 2);
		
Assert.assertEquals(result, 2);

lub wywo³ujemy funkcjê, która jest napisana w innej klasie, wynik przypisujemy do zmiennej result, a nastêpnie porownujego go w funkcji assertsEquals
-----------------------------------------------------

test ng - aby metoda siê nie uruchamia³a nale¿y zrobiæ coœ takiego:
@Test(enabled=false)

	public void testMethod1() {

	System.out.println("testMethod1");

  }

------------------------------
testng 
Assert.assertTrue(true); - sprawdza czy warunek w nawiasie jest prawdziwy, jeœli nie, wyrzuca b³¹d
---------------------------------------------------
listeners w testng u¿ywa siê wtedy kiedy:
- mamy jak¹s funkcjê i w zale¿noœci czy ona siê wykona poprawnie czy nie, to w zaimplementowanej klasie ITestListener uruchaminay w³aœnie funkcjê, która ma siê uruchomiæ po poprawnie wykonanym teœcie. 
-----------------------------------------
GRID
java -jar selenium-server-standalone-3.14.0.jar -role hub -port 5555
java -jar selenium-server-standalone-3.14.0.jar -role node -hub http://localhost:5555/grid/register -port 6666
----------------
to wpisujemy w przegl¹darce, ¿eby zobaczyæ, co jest uruchomione
http://localhost:5555/grid/console
---------------------------------------------
ustawienie przegl¹darki 

java -jar selenium-server-standalone-3.14.0.jar -role node -hub http://localhost:5555/grid/register -port 6666 -browser browserName=firefox,version=62.0,maxinstances=1,platform=WIN10
---------------
moje ip to 192.168.1.7
-----------------
komenda czytaj¹ca plik json 
najpierw hub musi byæ ustawiony na post 5555
java -jar selenium-server-standalone-3.14.0.jar -role node -nodeConfig grid.json
-----------------------------

chrome i firefox driver

System.setProperty("webdriver.gecko.driver", "C://Users//Bartek//eclipse-workspace/geckodriver.exe");
System.setProperty("webdriver.chrome.driver", "C://Users//Bartek//eclipse-workspace/chromedriver.exe");
--------------------------------

ustawienie driverów dla chrome i forefox 

java -Dwebdriver.gecko.driver="C://Users//Bartek//eclipse-workspace/geckodriver.exe" -Dwebdriver.chrome.driver="C://Users//Bartek//eclipse-workspace/chromedriver.exe" -jar selenium-server-standalone-3.14.0.jar -role node -nodeConfig grid.json

---------------------------------------------------
uruchomienie grida, klasa before 
uzycie klasy DesiredCapabilities

@BeforeEach
	void setUp() throws Exception {
		  baseUrl = "https://www.expedia.com/";
		  nodeURL = "http://192.168.1.7:7777/wd/hub";
		  DesiredCapabilities caps = DesiredCapabilities.chrome();
			caps.setBrowserName("chrome");
			caps.setPlatform(Platform.WINDOWS);
			driver = new RemoteWebDriver(new URL(nodeURL), caps);
			framework_factory searchPage = new framework_factory(driver);
			
			driver.manage().window().maximize();
			driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
			driver.get(baseUrl);


a normalnie before wygl¹da tak:

@BeforeEach
	void setUp() throws Exception {
		System.setProperty("webdriver.chrome.driver", "C://Users//Bartek//eclipse-workspace/chromedriver.exe");
		driver = new ChromeDriver();
		baseUrl = "https://jqueryui.com/slider/";
		driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
		driver.manage().window().maximize();	
	}
------------------------------------------------------
maven 
komenda do tworzenia projektu:

cd eclipse-workspace a póŸniej 

mvn archetype:generate -DgroupId=com.expedia.cli -DartifactId=flightsbookingcli -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false

ale tak samo mo¿na utworzyæ projekt w eclipse bez u¿ycia komendy maven 
-------------------------------------------------------------
pobranie wszystkich dependencies, które mamy okreslone w pliku .pom 
ta komenda pobiera pliku do katalogu workspace 

mvn dependency:sources
---------------------------------------------------------------------------
po³¹czenie pliku App.java który znajduje siê w src/main/java z dependencies 
- gdyby jakieœ funkcje nie dzia³a³y w pliku App.java
komenda: 
mvn dependency:resolve -DClassifier=javadoc
-------------

jenkins
komenda cmd, aby uruchomiæ jenkins - trzeba uruchomiæ ja w lokalizacji, gdzie zanjduje siê jenkins,
java -jar jenkins.war 
-----------------------------
has³o i login do jenkins to admin, admin
-----------------

git - repository url 
https://github.com/BartekSelenium/bartselenium.git

adres do mojego gita url 
https://github.com/BartekSelenium/bartselenium

git exe na moim dysku to 
C:\Program Files\Git\bin\git.exe
--------------------------------------------------------

- commit to zmiany jakie zrobiliœmy w pliku
--------------------
w folderze gdzie s¹ moje pliki java wpisujê komendê
- git init
Nastêpnie chcemy dodaæ nasz plik do utworzonego repozytorium:
- git add index.html
- jeœli mam dwa pliki to dwa razy ta komenda, albo ra¿ mo¿na u¿yæ komendy git add . 
- póŸniej dajê 
-git commit -m "my first repository"
-
Teraz musimy siê po³¹czyæ z naszym zdalnym repozytorium
- git remote add origin https://github.com/BartekSelenium/bartselenium.git
i póŸniej dajemy git push -u origin master (trzeba bêdzie podaæ dane do logowania)

- git pull pobiera z reporytorium wszystkie pliki i zapisuje je u mnie na dysku 
- u mnie pull musia³ byæ taki, bo by³ b³¹d 
git pull origin master --allow-unrelated-histories  - i ta komenda pobra³a mi z serwera plik readme - tak wiec teraz mogê zrobiæ push
-czyli 

-------------------
instrukcja github 
https://www.flynerd.pl/2018/02/github-dla-zielonych-pierwsze-repozytorium.html
-----------------------
pom
C:\Users\Bartek\eclipse-workspace\flightsbooking\pom.xml
-----------------------

Cucumber
uruchomienie testu z Cucumber 
import cucumber.api.CucumberOptions;
import cucumber.api.junit.Cucumber;
-----------------------------------
klasa abstrakcyjna: mam jedn¹ klasê abstrakcyjn¹ 
-------------------

CarsInterface43 obiekt = new CarsInterfaceImplements43();
		// to oznacza, ¿e implementujemy obiekt tak naprawdê klasy CarsInterfaceImplements43
		// czyli mamy dostêp do funkcji engineStart
		
		// ale mo¿e byæ te¿ klasycznie, czyli 
		//CarsInterfaceImplements43 obiekt = new CarsInterfaceImplements43();
----------------------------------------------------------

Klasa abstrakcyjna:
- public abstract void uruchom_silnik (String kluczyk, int ilosc); // to jest metoda abstrakcyjna, która nie mo¿e mieæ body
	// czyli ta funkcja nie ma nawiasów 
	//ka¿da kolejna klasa bêdzie musiala implementowaæ tê metodê

dalej

nie da siê tworzyæ obiektów klasy abstrakcyjnej
obiekty po prostu tworzymy w klasie, która rozszerza klasê abstrakcyjne 

ale dlaczego da siê tworzyæ konstruktor w klasie abstrakcyjnej, jak z niego póŸniej nie mogê korzystaæ ?
-------------

interface - > jeœli dana klasa implementuje interfejs (implements) to musi zaapliwoaæ wszystkie metody, jakie s¹ w interfejsie 
- zwyk³a klasa mo¿e implementowaæ kilka interfejsów i to jest róznica w stosunku do klas abstr
- tworzenie obiektu inaczej, czyli:

CarsInterface43 obiekt = new CarsInterfaceImplements43();

w tym przypadku chodzi o to, ¿e nie mo¿na tworzyæ obiektu klasy interfejs (jak w kl abstr), dlatego nie mo¿na napisaæ CarsInterface43 obiekt = new CarsInterface43(); - (po prostu CarsInterface43  jest interfejsem)
- a jak napiszemy CarsInterface43 obiekt = new CarsInterfaceImplements43(); to tworzymy obiekt klasy CarsInterfaceImplements43, ale mamy dostêp tylko do funkcji z klasy CarsInterface43. 
-------------------------

mapa, lista

Map<String, String> lista = new HashMap<>();
		
		lista.put("Ala", "kotka");
		lista.put("Basia", "pieska");
		lista.put("Ola", "krolika");
		
		System.out.println(lista); // takie coœ da w konsoli {Basia=pieska, Ola=krolika, Ala=kotka}
-----------------------------------
listy mapy drukowanie 
tutaj mamy akurat listê list 
List<String> lista1 = new ArrayList<String>();
		lista1.add("ala");
		lista1.add("ma");
		lista1.add("kota");
		
		
		List<String> lista2 = new ArrayList<String>();
		lista2.add("bartek");
		lista2.add("uczy");
		lista2.add("sie");
		
		List<List<String>> lista3 = new ArrayList<List<String>>();
		lista3.add(lista1);
		lista3.add(lista2);
		
		System.out.println(lista3.get(1).get(0));
--------------------------------------------
Arrays as list drukowanie
String a[] = new String[]{"abc","klm","xyz","pqr"};
		 List bbb = Arrays.asList(a);
		 System.out.println(bbb);
----------------------------------

klasa dropdown 
package src;

import org.openqa.selenium.WebDriver;
import java.util.ArrayList;
import org.testng.Assert;
import org.testng.annotations.Test;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.support.ui.Select;

public class dropdownAssert {

	public static void main(String[] args) {
		
		//List<String> zmienna = moja_funkcja();
		//System.out.println(zmienna);
		
	}
	
	public static List<String> moja_funkcja() {
		WebDriver driver;
		String baseUrl;
		System.setProperty("webdriver.chrome.driver", "C://Users//Bartek//eclipse-workspace/chromedriver.exe");
		driver = new ChromeDriver();
		baseUrl = "http://letskodeit.teachable.com/pages/practice";
		driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
		driver.manage().window().maximize();	
		
		driver.get(baseUrl);
		WebElement ele1 = driver.findElement(By.id("carselect"));
		Select lista_dropdown = new Select(ele1);
		List<WebElement> lista_drukowanie = lista_dropdown.getOptions();
		List<String> lista_stringow = new ArrayList<String>();
		
		for (WebElement element : lista_drukowanie) {
			lista_stringow.add(element.getText());
		}
		return lista_stringow;
	}
	}

i teraz druga klasa testuj¹ca 

package src;

import java.util.ArrayList;
import java.util.List;

import org.testng.Assert;
import org.testng.annotations.Test;

public class dropdownAssertTest {

	List<String> wynik = new ArrayList<String>();
	
	@Test
	public void testowaine_dropdown () {
		dropdownAssert obiekt_klasy_dropdownAssert = new dropdownAssert();
		wynik = obiekt_klasy_dropdownAssert.moja_funkcja();
		List<String> spodziewany = new ArrayList<String>();
		spodziewany.add("BMW");
		spodziewany.add("Benz");
		spodziewany.add("Hondaz");
		Assert.assertEquals(wynik, spodziewany);
	}
	
	
}
-----------------------------------------------------------------------

xpath wyszukuje elementy h1 oraz span w konrektnej klasie
return driver.findElement(By.className("mT")).findElements(By.xpath("*[self::h1 or self::span]")).stream().map(WebElement::getText).map(String::trim)
			.collect(Collectors.toList());
------------------------------------------------------

Klasy abstrakcyjne:
- nie mo¿na tworzyæ obiektu klasy abstrakcyjnej, dlatego jeœli w nowej klasie chcemy skorzystaæ z metod klasy abstrakcyjnej to w tej nowej metodzie musimy u¿yæ s³owa 'extends'
----------------------

Dziedziczenie:
- mamy klasê g³ówn¹, która ma w sobie konstruktor - tak wiêc klasa, która dziedizczy, te¿ musi mieæ konstruktor
- klasa, która dziedziczy mo¿e nadpisywaæ metody, które dziedziczy s³owem Override lub ca³kowicie je kopiowaæ za pomoc¹ s³owa super
- po co robiæ dziedziczenie, jeœli mo¿emy stworzyæ obiekt klasy g³ównej za pomoc¹ s³owa new w naszej drugiej klsie i w ten sposób mo¿emy korzystaæ ze wszystkich funkcjonalnoœci klasy g³ównej ????????????
- jak do g³ównej mojej klasy doda³em s³owo "abstract" to nic sie nie zmieni³o - wiêc po co to stosowaæ ?
- nie mo¿na tworzyæ obiektu interfajsu i klasy abstrakcyjnej 
-------------------------------

xpath mój w³asny
//legend[contains(text(),'Checkbox Example')]//following-sibling::label/input[contains(@value,'bmw')]
-------------------------------
drukowanie i modyfikowanie hash mapy
klucze i wartoœci za pomoc¹ stream 

Map<String, Integer> wyplata = new HashMap<>();
		wyplata.put("John", 40000);
		wyplata.put("Freddy", 30000);
		wyplata.put("Samuel", 50000);
		
		wyplata.keySet().stream().forEach(element -> System.out.println(element+" ooo"));
		wyplata.values().stream().forEach(ele -> System.out.println(ele+1000));
------------------------------------------------------
filtrowanie elementów, stream 

List<String> names = Arrays.asList("Angela", "Aaron", "Bob", "Claire", "David");
		
		List<String> names2 = names.stream().filter(element -> element.startsWith("A"))
				.collect(Collectors.toList());
		System.out.println(names2);
-----------------------------------------------------

streamy
strza³eczka oznacza po prostu wyra¿enie lambda, czyli element i po strza³ce, co robiê na tym elemencie

dwukroopki - to oznacza najczêœciej klasa::metodWtejKlasia 

ale mo¿e byæ te¿ coœ takiego 
names.stream().forEach(System.out::println);

dwa dwukropki to referencja metod

mo¿emy zrobiæ coœ takiego 
List<String> names = Arrays.asList("Angela", "Aaron", "Bob", "Claire", "David");

		names.replaceAll(ele -> ele.toUpperCase());

lub za pomoc¹ referencji 

		names.replaceAll(String::toUpperCase);
---------------------------------------------------------------------

drukowanie, stream, wszystkch elementów z liter¹ a 
List<String> names = Arrays.asList("Angela", "Aaron", "Bob", "Claire", "David");
		
		names
		.stream()
		.filter(ele -> ele.contains("a"))
		.forEach(ele -> System.out.println(ele));
----------------------------------------------------------------------------

kurs internetowy 
https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-lambdas
--------------------------

sortowanie tablicy intów za pomoc¹ stream 
List<Integer> numbers = Arrays.asList(5, 3, 50, 24, 40, 2, 9, 18);
List<Integer> numbers2 = numbers
			.stream()
			.sorted((a,b) -> Integer.compare (a,b))
			.collect(Collectors.toList());


lub za pomoc¹ referencji metod 
List<Integer> numbers2 = numbers
			.stream()
			.sorted(Integer::compare)
			.collect(Collectors.toList());
-------------------------------------------------------------------------------

do streama mo¿emy podaæ listê obietków i j¹ posortowaæ:
ale wa¿ne jest to, ¿e musimy wtedy stworzyæ obiket klasy, w której jest funkcja sortuj¹ca
czyli referencja metody sortuj¹cej jest na nowo stworzonym obiekcie, a nie na klasie jak zawsze 

public class BicycleComparator implements Comparator <Bicycle> {

	@Override
	public int compare(Bicycle a, Bicycle b) {
		return a.getFrameSize().compareTo(b.getFrameSize());
	}


public static void main (String[] args) {
		
		 ArrayList<Bicycle> listOfBicycles = new ArrayList<Bicycle>();
		 listOfBicycles.add(new Bicycle ("jeden", 40));
		 listOfBicycles.add(new Bicycle ("dwa", 20));
		 listOfBicycles.add(new Bicycle ("trzy", 50));
		 listOfBicycles.add(new Bicycle ("cztery", 10));
		 listOfBicycles.add(new Bicycle ("piec", 30));
		
		 ArrayList<Bicycle> listOfBicycles2 = new ArrayList<Bicycle>();
		 
		 BicycleComparator obiekt = new BicycleComparator();
		 
		 listOfBicycles2 = (ArrayList<Bicycle>) listOfBicycles
		 .stream()
		 .sorted((a,b) -> obiekt.compare(a, b))  // to jest wyra¿enie lambda
		 .collect(Collectors.toList());
	
		 System.out.println(listOfBicycles2);
-----------------------------------------------------------------------------------
ale mo¿na te¿ zrobiæ to za pomoc¹ referencji metod
------------------
Optional 
@Test
	public void whenCreatesEmptyOptional_thenCorrect() {
	    String napis = "alamakota";
	    Optional <String> napis2 = Optional.ofNullable(napis);
	    assertTrue(napis2.isPresent());
	    

Optional<String> opt = Optional.of("Baeldung");
    assertFalse(opt.isEmpty());

Optional <String> napis = Optional.of("alamakota");
napis.ifPresent(ele -> System.out.println(ele.length()));


String napis = null;
		String napis2 = Optional.ofNullable(napis).orElse("alamakota");

assertEquals("alamakota", napis2); // pierwsza wartoœæ, to wartoœæ expected
---------------------------

aby uzyskaæ wartoœæ z Optionala musimy u¿yæ metody GET 

Optional<String> napis = Optional.of("alama");
	String napis2 = napis.get();
	assertEquals("alama", napis2);
-----------------------------------------------------

optional oraz przekazanie obiektu jako argumentu do metody funkcji 

public static boolean czyJest (Modem obiektModem) {
		return Optional.ofNullable(obiektModem)
				.map(Modem::getModem)
				.filter(wartosc -> wartosc <= 100)
				.isPresent();
		
	}

Modem::getModem to po prostu getter - > zwraca wartosc int i tyle // getter, setter 


test robimy za pomoc¹ czegoœ takiego 

@Test
	public void testuj() {
		
		assertTrue(czyJest(new Modem(20.0)));
		
		
	}

-------------------------------------------------------------------
- jeœli chcemy korzystaæ z map, stream itd to na zwyk³ej zmiennej siê to nie uda - > musimy przerobiæ zwyk³y obiket na Optionala i wtedy mo¿na korzystaæ ze streamów itd

Przyk³ad:
PersonOptional persOpt = new PersonOptional("ala", 19);
		Optional <PersonOptional> OptionalPersOpt = Optional.of(persOpt);
		
		Optional<Optional<String>> ala = OptionalPersOpt.map(PersonOptional::getName);
------------------------------------------

wyswietlanie pierwszej nie nullowej wartosci
getbye i gethello to zwykle metody które zwracaj¹ napisy 

Optional<String> znalazlem = Stream.of(getEmpty(), getBye(), getHello())
				.filter(Optional::isPresent)
				.map(Optional::get)
				.findFirst();
				System.out.println(znalazlem);
				String cos = znalazlem.get();
				System.out.println(cos);
----------------------------------------------------------------------
listê optionali robimy po prostu aarays.asList

Aby z listy optional zrobiæ listê Stringów, u¿ywamy po prostu Optional::get

List<Optional<String>> names = Arrays.asList(getEmpty(), getHello(), getBye());
		
		List<String> names2 = names
				.stream()
				.filter(Optional::isPresent)
				.map(Optional::get)
				.collect(Collectors.toList());
		
		System.out.println(names2);
-----------------------------------------------------------------------------

u¿ycie flatMap 
na ten moment niestety jedynie takie u¿ycie znam, do flatmapy przekazujemy metodê z danej klasy, która zwraca optionala, a z tego optionala robiony jest zwyk³y string

 String name = personOptional
      .flatMap(Person::getName)
      .orElse("");
    assertEquals("john", name);
----------------------------------------------------------------

consumer 
List<String> lista = Arrays.asList("ala", "ma", "kota", "psa");

		Consumer<String> consumer = ele -> System.out.println(ele);
		
		lista.stream().forEach(consumer);
---------------------------------------------------------------------------
comparator 

ArrayList<Employee> employees = new ArrayList<Employee>();
		employees.add(new Employee ("John", 25, 3000.0, 321321777));
		employees.add(new Employee ("Ace", 22, 2000.0, 321321444));
		employees.add(new Employee ("Keith", 35, 4000.0, 321321111));
		
		
		Comparator<Employee> employeeNameComparator = Comparator.comparing(Employee::getName);
		
		Collections.sort(employees, employeeNameComparator);
---------------------------------

dwa sposoby tworzenia list obiektów 

Employee[] sortedEmployeesByName = new Employee[] { new Employee("Ace", 22, 2000, 5924001), new Employee("John", 25, 3000, 9922001), new Employee("Keith", 35, 4000, 3924401) };

oraz klasyczny 
ArrayList<Employee> employees = new ArrayList<Employee>();
		employees.add(new Employee ("John", 25, 3000.0, 321321777));
		employees.add(new Employee ("Ace", 22, 2000.0, 321321444));
		employees.add(new Employee ("Keith", 35, 4000.0, 321321111));
-------------------------------------------------------------------------------------------

drukowaine listy obiektów 

jeœli obiekt wygl¹da jak poni¿ej, to zawsze musimy nadpisaæ metodê toString 

public class Employee {
	String name;
	int age;
	double salary;
	long mobile;
	
	@Override
	public String toString() {
		 return this.name + " " + String.valueOf(this.age) + " " + String.valueOf(this.salary);
	}
-----------------------------------------------------------

komparator, który sortuje odwrotnie 
Comparator<Employee> komparator = Comparator.comparing(Employee::getName, 
				(s1, s2) -> { return s1.compareTo(s2); }
				);

ewentualnie coœ takiego 

w comparable po prostu nadpisujemy sobie w³asny komparator, jak on ma sortowaæ, i wtedy kiedy u¿ywamy metody sort() to podajemy tylko listê bez ¿adnch dodatkowych argumentów.
A comparing to 2 argumenty i tam po prostu mo¿emy korzystaæ z gotowych rozwi¹zañ

Comparator<Employee> komparator = Comparator.comparing(Employee::getName);
		Comparator<Employee> komparatorOdwrocony = komparator.reversed();
--------------------------------------------------------------------------------------
natural order po implements Comparable<Employee>
Comparator<Employee> komparator = Comparator.<Employee> naturalOrder();
		Collections.sort(employees, komparator);

mo¿na te¿ u¿yæ metody reverseOrder();
-------------------------------------------
----------------------------------------------------------
uruchamianie grida na moim komputerze 
- trzeba pobraæ selenium server
-uruchamimy tam gdzie jest katalog tak¹ komedn¹ 
- java -jar selenium-server-standalone-3.14.0.jar -role hub
- najpierw trzeba zarejestrowaæ huba póŸniej noda 
czyli 
java -jar selenium-server-standalone-3.14.0.jar -role hub

póŸniej 
java -jar selenium-server-standalone-3.14.0.jar -role node -hub http://localhost:4444/grid/register -port 5555

ustawienie iloœci przegl¹darek
java -jar selenium-server-standalone-3.14.0.jar -role node -hub http://localhost:4444/grid/register -browser browserName=chrome,version=69.0,maxinstances=1,platform=WINDOWS -port 5555

te komendy mo¿na tak samo zczytywaæ z pliku json 
java -jar selenium-server-standalone-3.14.0.jar -role node -nodeConfig grid_node.json

ewentualnie ze zmienn¹ 
-DWebDriver=chrome.driver="location";
-------------------------
--------------------------------------------------

uruchomienie testu na gridzie - trzeba tylko podmieniæ kilka linii i tyle - webdriver na remotewebdriver

public static List<String> moja_funkcja() throws MalformedURLException {
		//WebDriver driver;
		String baseUrl;
		String nodeUrl = "http://192.168.1.6:5556/wd/hub";
		DesiredCapabilities caps = DesiredCapabilities.chrome();
		caps.setBrowserName("chrome");
		caps.setPlatform(Platform.WIN10);
		RemoteWebDriver driver = new RemoteWebDriver(new URL(nodeUrl), caps);
		
		
		
		System.setProperty("webdriver.chrome.driver", "C://Users//Bartek//eclipse-workspace/chromedriver.exe");
		//driver = new ChromeDriver();
		baseUrl = "http://letskodeit.teachable.com/pages/practice";
		driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
		driver.manage().window().maximize();	
		
		driver.get(baseUrl);
		WebElement ele1 = driver.findElement(By.id("carselect"));
-------------------------------------------------------------------------------------------------------------------------------------------------------------
mo¿na imprelemtnowaæ Comparator (ma metodê compare) oraz Comparable (ma metodê compareTo), w Comparable robimy Override metody compareTo

tworzenie komparator 
public class Employee{    // tutaj nie ma nic w tej klasie 
	private int ranking;
	private String name;
	private int age;

nastêpnie musimy stworzyæ osobn¹ klasê do komparatora 
public class EmployeeAgeComparator implements Comparator<Employee>{

	@Override
	public int compare (Employee playerFirst, Employee playerSecond) {
		return (playerFirst.getAge() - playerSecond.getAge());
	}	
}

in nastêpnie w ostateczej klasie wywo³ujemy ten obiekt komparatora i sortujemy 
EmployeeAgeComparator komparatorAge = new EmployeeAgeComparator();
		
		
		System.out.println(lista);
		Collections.sort(lista, komparatorAge);
		System.out.println(lista);
		
-------------------------------------------------------------------------

tworzenie komparator z u¿yciem lambad, to jest identyczny komparator jak comparing 

Comparator<Employee> komparatorB = (Employee emp1, Employee emp2) ->
		emp1.getRanking() - emp2.getRanking();
		
		
		System.out.println(lista);
		Collections.sort(lista, komparatorB);
-------------------------------------------------------------

konwertowanie tablicy int do listy int 
int[] lista = {5, 1, 7, 66, 88, 89, 123, 200, 2, 255};
	
	List<Integer> lista2 = Ints.asList(lista);
----------------------------------------------------------

List<Map.Entry<String, ?>> entryList = new List<>(//initialization);
List<String> stringList = entryList.stream().map(Entry::getKey).collect(Collectors.toList());

---------------
lista przy drukowaniu jest oznaczana jako {}
a tablice jako [] - chyba 
---------------------------------------------------------

Map.Entry<Integer, String> entry to po prostu typ danych 
jak np 
String entry 
--------------------------------------

HashMap<Integer, String> mapa2 = new HashMap<>();
	    mapa2.put(7, "ala");
	    mapa2.put(5, "ma");
	    mapa2.put(6, "kota");
	    
	    List<Map.Entry<Integer,String>> listaMap = new ArrayList<>(mapa2.entrySet());    
	    
	    Integer[] sortedKeys = new Integer[] {5, 6, 7};
	    
	    Collections.sort(listaMap, new Comparator<Entry<Integer, String>>()
	    {
	    	@Override
	    	public int compare(Entry<Integer, String> o1, Entry<Integer, String> o2) {
	    		return o1.getKey().compareTo(o2.getKey());
	    	}
	    	
	    });
	    
	    Map<Integer, String> posortowana = new LinkedHashMap<>();
	    
	    for (Map.Entry<Integer, String> entry : listaMap) {
	    	posortowana.put(entry.getKey(), entry.getValue());
	    }

----------------------------------------------------------------------

sortowanie tablicy obiektów za pomoc¹ komparatora, sortowanie po imieniu 

ArrayList<Employee> employees = new ArrayList<Employee>();
		employees.add(new Employee ("John", 25, 3000));
		employees.add(new Employee ("Ace", 22, 2000));
		employees.add(new Employee ("Keith", 35, 4000));

public class Employee implements Comparable{

@Override
	public int compareTo(Object obj) {
		Employee emp  = (Employee) obj;
		return getName().compareTo(emp.getName());
	}

Collections.sort(employees);
		System.out.println(employees);
----------------------------------------------------------------

ostateczna zasada: comparator implementujemy w klasie, w której robimy porównanie, czyli 

public class BicycleComparator2 implements Comparator <Bicycle2>{
	
	@Override
	public int compare(Bicycle2 o1, Bicycle2 o2) {
		return o1.getBrand().compareTo(o2.getBrand());
	}
	
	public static void main (String[] args) {
		
		BicycleComparator2 obiekt = new BicycleComparator2();


BicycleComparator2 obiekt = new BicycleComparator2();	
		
	ArrayList<Bicycle2> lista = new ArrayList<Bicycle2>();
	
	lista.add(new Bicycle2 ("ma", 20));
	lista.add(new Bicycle2 ("ala", 30));
	lista.add(new Bicycle2 ("ja", 24));
	
	ArrayList<Bicycle2> listaPosortowana = new ArrayList<Bicycle2>();
	
	listaPosortowana = (ArrayList<Bicycle2>) lista
	.stream()
	.sorted( (a,b) ->  obiekt.compare(a, b))
	.collect(Collectors.toList());
	
	System.out.println(listaPosortowana)


natomiast implements Comparable robimy w klasie obiektu 
public class Player implements Comparable<Player> {
     
    //...
    @Override
    public int compareTo(Player otherPlayer) {
        return (this.getRanking() - otherPlayer.getRanking());
    }
}

--------------------------------------
warunek? wyra¿enie1 : wyra¿enie2;

Jak robiæ streamy ?

https://www.baeldung.com/java-8-streams

Collection<String> kolekcja = Arrays.asList("a", "b", "c");
	Stream<String> streamKolekcji = kolekcja.stream();

kolejny sposób 
Stream<String> stream = Stream.of("a", "b", "c");

kolejny sposób 
String[] tablica = new String[] {"a", "b", "c"};
		Stream<String> stream = Arrays.stream(tablica);

------
drukowanie streama 
Stream<Integer> intStream = Stream.iterate(40, n -> n+2).limit(20); 
		intStream.forEach(ele -> System.out.println(ele));
-------------------------------------------------------------

Stream<String> cos = Stream.of("a", "b", "c", "d", "bart").filter(ele -> ele.contains("b"));


Stream<String> cos = Stream.of("a", "hhbbb", "c", "d", "bart").filter(ele -> ele.contains("b"));
		java.util.Optional<String> anyElement = cos.findAny();
		String ele = anyElement.get();
---------------------------------------

filtrowanie stream ze s³owem return oraz u¿ycie nawiasów

Stream<String> ggg = lista
				.stream()
				.filter(  ele -> 
				{
				return ele.contains("b");       }
						
						);
-------------------------------------------------------------------------

kolejnoœæ wykonywania filter oraz map 

List<String> lista = Arrays.asList("aaaa", "bbb", "ccc");
		counter = 0;
		
		java.util.Optional<String> stream2 = lista.stream().filter(element -> {
		    System.out.println("filer was called");
		    return element.contains("c");
		}).map(element -> {
			System.out.println("upper case was called");;
		    return element.toUpperCase();
		}).findFirst();
			
		String ele = stream2.get();
		System.out.println(ele);

wynik dzi³ania funkcji to 

filer was called
filer was called
filer was called
upper case was called
CCC
-----------------------------------------------

filtrowanie mapy po kluczu, wartoœci mapowanie stream 

Map<String, String> books = new HashMap<>();
		books.put("978-0201633610", "Design patterns : elements of reusable object-oriented software");
		books.put("978-1617291999", "Java 8 in Action: Lambdas, Streams, and functional-style programming");
		books.put("978-0134685991", "Effective Java");
		
		
		
		java.util.Optional<String> wynik = books
				.entrySet()
				.stream()
				.filter(ele -> ele.getValue().equals("Effective Java"))
				.map(Map.Entry::getKey)
				.findFirst();
		
		System.out.println(wynik.get());
assertEquals(wynik.get(), "Effective Java");
-------------------------------------------------------------

klasa abstrakcyjna - klasa g³ówna 

public abstract class BaseFileReader {

public abstract String konwertuj (String napis);

public List<String> pobierzListe (List<String> lista) {
	
	return 
	lista
	.stream()
	.map(this::konwertuj)
	.collect(Collectors.toList());
}

oraz klasa, która dziedziczy 

----------------------

public class LoweCaseFileReader extends BaseFileReader {
	
	@Override
	public String konwertuj (String napis) {
		return napis.toUpperCase();
	}

	
	public static void main (String[] args) {
		LoweCaseFileReader obiekt = new LoweCaseFileReader();
		
		List<String> lista = new ArrayList<String>();
		lista.add("ala");
		lista.add("ma");
		lista.add("kota");
		
		System.out.println(obiekt.pobierzListe(lista));
		
		
	}
}

-----------------------------------------------------------------------------

interface 
klasa która implementuje interface, to musi te¿ nadpisaæ metody abstrakcyjne, które s¹ w interfajsie - czyli identycznie jak w klasie abstrakcyjnej 

-----------------------------------------------------------------------------

nauka dziedziczenia na postawie interia.pl

klasa g³ówna interia.pl

public class interiaStronaGlowna {
	
	
public static void main (String[] args) throws InterruptedException {
	
	
	
		WebDriver driver;
		String baseUrl;
		
			System.setProperty("webdriver.chrome.driver", "C://Users//Bartek//eclipse-workspace/chromedriver.exe");
			driver = new ChromeDriver();
			baseUrl = "https://www.interia.pl/";
			driver.manage().window().maximize();
		
		
			driver.get(baseUrl);
			//WebElement loginLink = driver.findElement(By.xpath("//div[@class='calendar-image']"));
			
			Thread.sleep(6000);
			WebElement przejdzDoSerwisu = driver.findElement(By.xpath("//button[@class='rodo-popup-agree']"));
			przejdzDoSerwisu.click();
			
			Thread.sleep(3000);
			//List<WebElement> moja_lista = driver.findElements(By.xpath("//a[@class='portal-menu-a']"));
			 //Actions najedz = new Actions(driver);
			 //najedz.clickAndHold(loginLink).perform();
			 //Thread.sleep(3000);
			 //WebElement tekst = driver.findElement(By.xpath("//p[@class='calendar-details-desc']"));
			  //String toolTipText = tekst.getText();
			  //System.out.println(toolTipText);
			  
			  //if (toolTipText.contains("wystrzelona")) {
			//	  System.out.println("megaa");
			  //}
		
			  
			  WebElement motoryzacja = driver.findElement(By.xpath("//a[@title='Moto']"));
			  Actions actions = new Actions(driver);
			  actions.moveToElement(motoryzacja);
			  actions.perform();
			  motoryzacja.click();
			  
			  podstronaMotoryzacja obiektPodstronaMotoryzacja = new podstronaMotoryzacja(driver);
			  obiektPodstronaMotoryzacja.getMotoryzacjaWiadomosci().kliknijLinkWiadomosci();
		
	
			driver.quit();
		}


}
------------

podstrona motoryzacja 

public class podstronaMotoryzacja extends webdriverPage{

	private motoryzacjaWiadomosci obiekMotoryzacjaWiadomosci;
	
	private String napis;
	
	
//jesli chcemy korzystac z obiektu wy¿ej, to musimy zrobic getter i setter 
	public podstronaMotoryzacja(WebDriver driver) {
		super(driver);
		obiekMotoryzacjaWiadomosci = new motoryzacjaWiadomosci(driver);
	}
	
	
	//to dzia³a - to po prostu tworzenie obiektu
	//motoryzacjaWiadomosci obiekt = new motoryzacjaWiadomosci(driver);
	
	
	//getter
	public motoryzacjaWiadomosci getMotoryzacjaWiadomosci() {
		return obiekMotoryzacjaWiadomosci;
	}
	
	//getter
	public String getNapis() {
		return napis;
	}
		
	
	
	
}
---------------------

podstrona wiadomoœci

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;

public class motoryzacjaWiadomosci extends webdriverPage{

	public motoryzacjaWiadomosci(WebDriver driver) {
		super(driver);
	}

	
	
	public void kliknijLinkWiadomosci () throws InterruptedException {
		Thread.sleep(5000);
		driver.findElement(By.xpath("//li/a[@href='/wiadomosci']")).click();
		Thread.sleep(5000);
	}
	

}

------------------------------
klasa webdriver 

import org.openqa.selenium.WebDriver;

public class webdriverPage {
	
	protected final WebDriver driver;
	
	public webdriverPage (WebDriver driver) {
		this.driver = driver;
	}
	
	

}
------------------------------------------------------------

enum oraz tworzenie obiektów w enumie


public class Pizza {
    
	public enum pizzaStatus {
		ORDERED("zamowiona"),
		READY("gotowa"),
		DELIVERED("dostarczona");
		
		public String status;
		
		pizzaStatus (String status) {
			this.status = status;
		}
		
		public String getValue () {
			return status;
		}
		
	}


------oraz tworzenie obiektu bez s³owa new 

public class PizzaEnum extends Pizza{
	
	public String wywolaj (pizzaStatus status) {
		return status.getValue();
	}
	
	public static void main (String[] args) {
		
		PizzaEnum obiekt = new PizzaEnum();
		System.out.println(pizzaStatus.ORDERED.getValue());
		
		String ala = "dostarczona";
		
		pizzaStatus obiekEnuma = pizzaStatus.DELIVERED;
		
		System.out.println(obiekEnuma.getValue());

	}


}

--------------------------------------------------------------------